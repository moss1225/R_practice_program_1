1、编写快速的R代码
* 通过向量化的方式优化你的R代码，使用自检码编译，以及其他的一些方式；
* 将你的代码中最消耗CPU的核心部分用编译性语句编译，如使用C或C++；
* 将你的代码用某种并行的方式编写

2、避免使用for循环
* 做个时间对比
x <- runif(1000000)
y <- runif(1000000)
z <- vector( length = 1000000 )
system.time(z <- x + y)
system.time(for(i in 1:length(x)) z[i] <- x[i] + y[i])

3、函数编程与内存问题
* 向量赋值问题
z[3] <- 8
z <- "[<-"(z , 3 , value=8)
对于一个很长的向量，这可能会极大降低程序的运行速度。

* 改变时拷贝
与此相关的一个问题时，R会采用一种改变时拷贝(copy-on-change)的措施。
例如，如果我们继续使用上述程序来运行下面语句
y <- z
	   那么在此之后y与x将共享相同的内存区域。然后，只要他们其中一个发生了变化，那
么程序就会在另一块内存区域创建一份对象的拷贝，并且发生改变的那个向量将会占据这
块新内存区域。然而，只有第一次改变会受影响的，这是因为给转移的变量重新分配内存
就意味着两个变量不再存在内存共享的问题。函数tracemem()可以用来报告这种内存在分配
的情况。

4、避免内存拷贝（扩展案例）

5、利用Rprof()来寻找代码的瓶颈
	   Rprof()可以提供一份报告，(近似地)告诉你代码中调用的每个函数所消耗的时间。 
* 利用Rprof()来进行监视
		利用之前扩展案例中寻找幂次矩阵的三段代码，我们来展示Rprof()的用法。首先调用
Rprof()来启动监视器，然后运行我们的代码，再调用带NULL参数的Rprof()来结束监视。最
后，调用summaryRprof()来查看结果。
x <- runif(1000000)
Rprof() # 打开监视器
invisible(powers1(x , 8)) # 调用invisble()的调用是为了避免输入结果被展示出来。在这里我们当然不希望看到有powers1()返回100000行的矩阵！
Rprof(NULL) # 关闭监视器
summaryRprof() # 打印结果

6、字节码编译
       从2.13版本开始，R包含了一个字节码编译器，利用它你可以尝试加速代码。考虑我们在
第14.2.1节中的例子，作为一个平凡的案例，我们说明了：
z <- x + y
会比
for( i in 1:length(x)) z[i] <- x[i] + y[i]
       快出许多。尽管这样是明显的，但是我们可以了解一下字节码编译是如何工作的。让我们来
尝试一下：
library(compiler) # 引入编译包
f <- function() for (i in 1 : length(x)) z[i] <<- x[i] + y[i]
cf <-cmpfun(f) # 编译代码
system.time(cf)

7、内存无法装下数据怎么办
* 分块
		一种不需要使用额外R软件包的方法是从硬盘文件上分块读取你的数据。例如，假如我
们的目标是求出某些变量的均值或比例，那么可以使用read.table()中的skip参数。

*利用R软件包来进行内存管理
  		对于一些更复杂的情况，另一种可选的方法是使用一些特殊的R软件包来解决大量内存
的需求问题。
		其中一个软件包是RMySQL，它是r到SQL数据库的一个接口。要使用它你需要一些
数据库的知识。其思路在于，在数据库端用SQL语言来进行变量/预测值的选择操作，然后
用R读取SQL选择出的数据集。
		另一个有用的软件包是biglm，他可以在非常大数据集上进行回归和广义线性模型的分
析。他同样采用了分块的方法，大采用的不同的实现：每一个分块用来更新当前回归分析
需要的一些求和项，计算完成后这个分块即被丢弃。
		最后，有一些软件包采用了他们自己的存储管理方式，这与R中的内容管理是相互独立
的，因为这些软件包可以处理非常大的数据集。在这方面，目前两个用得最多的软件包是ff
和bigmemory，前者是通过将数据存放在硬盘上来会比内存限制，这一过程对于程序员来说
是完全透明的；而高度通用的bigmemory包功能类似，但它不仅可以将数据存储在硬盘上，还
可以将数据保存在机器的内存中，对于多核的机器而言是一个理想的选择。