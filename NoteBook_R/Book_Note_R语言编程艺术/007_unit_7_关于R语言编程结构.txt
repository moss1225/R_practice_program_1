1、for循环
z <- c( 1:10 )
for ( k in z ){ print ( k ) }

2、while循环
z <-1
while( z <= 10 ){ i = i + 4 }

3、repeat循环 和 break中断
repeat{
	i < i + 4
	if ( i > 10 ){ break }
}

4、next语句
next语句跳过本次循环的剩余部分，直接进入循环的下一次迭代。
i  <- 1
while(i <= 100){
i <- i+1
if( i %% 4 != 0 ) next
} # 输出4的倍数

5、对非向量集合的循环
R语言不支持直接对非向量集合的循环，但是有一些间接的方法可以做到这些：
（1）使用lapply()函数
data <- list( a = c ( 1 , 2 , 3 , 4 ) , b = c (2 , 3 ,4 , 5 ) )
lapply ( data , mean )
（2）使用get()函数
u <- matrix(c(1,1,2,2,3,4) , byrow = T , ncol =2)
v <- matrix(c(8 , 15 , 12 , 10 , 20 , 2) , byrow = T , ncol =2)
for( m in c( u , v )){
	z <- get( m )
	print( lm( z[ , 2 ] ~ z[ , 1] ) )
	}
}

6、if-else结构
if( r == 4){
	x=1
}else{
	x=3
	y=4
}

7、返回值 return
8、body(函数名)、page(函数名)打印函数信息

9、作用域_顶层环境
environment(参数)函数，返回对象所在环境
ls()函数，调用该函数，返回该函数下所有对象

10、关于ls()的进一步讨论
在函数中调用不带参数的ls()会返回当前的局部变量（包括参数）。
使用envir参数，ls()会输出函数调用链中任何一个框架的局部变量名。
f<-function(){
	d <- 8
	return(h(d,y))
}
h<-function( dee , yyy ){
	print(ls())
	print(ls(envir=parent.frame(n=1)))
	return(dee+(w+yyy))
}
调用及返回：
f(2)
[1] "dee" "yyy"
[1]"de"  "y"
[1]112
说明：
在parent.frame()中，参数n设定了要沿函数调用链向上几个框架。
在这里，当前正在执行h()，而h()是被f()调用的，所以n=1指的就是f()的框架。
于是就得到它的局部变量。

11、函数(几乎)没有副作用
函数式编程哲学的另外一个特征是，函数不会修改非局部变量。
w <- 12
f<-function(y){
	d<-8
	w <- w+1
	y <- y-2
	print(w)
	h <- function(){
		return (d*(w+y))
	}
	return ( h() )
}
t=4
f(t)

12、向上级层次进行写操作
对当前层次上的上级层次中任意变量进行写操作，
你可以在当前层此使用超赋值运算符<<- 
或者函数assin()。
（1）超赋值运算符
u<-2
f<-function(){
	u<<-3
}
u ; f() ; u

（2）超赋值运算符，从上级层次中逐层寻找，修改一次
f<-function(){ 
inc<-function(){x << x + 1}
x=1
inc()
return(x)
 }
f()    (result : 4)
x      (not found)

（3）用assign()函数对非局部变量进行写操作
two<-function(u){
	assign("u" , u + 2 , pos = .GlobalEnv)
	z<-2*z
}